# [P4] Logical design

In last week's practical class, you conducted requirements analysis and conceptual design for a simple company scenario. Now you can progress to a refinement.

In the logical step, you explicitly consider the target type of DBMS (database management system) – in this case, a relational DBMS. You model your data storage structures (relation schemas) in a manner that supports all the requirements for data integrity maintenance.

## From conceptual to logical design

In contrast to conceptual design, logical design is much more of a science than an art. 

In fact, the process can be broken down into a kind of algorithm, which will give good results if you have done your conceptual design properly and thoroughly.

1. Convert **entities to relations** (tables).
    - <div style="display:inline-block;width:15em;min-height:8em;border:1px black solid;padding:0.2em;vertical-align:text-top">
    **Employee**
    </div>
2. Convert **attributes to columns**. 
    - Also identify the **data type** for each column.
    - If a column must always have a value for every row of the table, mark it as "NOT NULL" (a special kind of **domain constraint**).
    - <div style="display:inline-block;width:15em;min-height:8em;border:1px black solid;padding:0.2em;vertical-align:text-top">
    **Employee**<br>
    employeeID *integer NOT NULL*<br>
    name *text NOT NULL*<br>
    address *text*<br>
    ...
    </div>
3. If the table already has a clear identifying attribute(s), make it (them) the **primary key** (underlined). Otherwise add a **surrogate key**. 
    - Remember to impose the **entity integrity constraint** – primary keys can never be null.
    - <div style="display:inline-block;width:15em;min-height:8em;border:1px black solid;padding:0.2em;vertical-align:text-top">
    **Employee**<br>
    employeeID *integer NOT NULL*<br>
    name *text NOT NULL*<br>
    address *text*<br>
    ...
    </div>
3. Resolve **relationships** by adding **foreign keys** as described in [the lecture](/13_logical_model.html#foreign-keys). 
    - For an M:N relationship, create an **associative entity**, a new linking table that contains foreign keys pointing to the tables participating in the relationship. 
    - Total participation constraints become NOT NULL constraints on the foreign key.
    - <div style="display:inline-block;white-space:nowrap"><div style="display:inline-block;width:15em;min-height:8em;border:1px black solid;padding:0.2em;vertical-align:text-top">
    **Employee**<br>
    <u>employeeID *integer NOT NULL*</u><br>
    name *text NOT NULL*<br>
    address *text*<br>
    [departmentID *integer NOT NULL*]{.udot}<br>
    ...
    </div><div style="display:inline-block;width: 2em;min-height:8em;vertical-align:text-top;position:relative"><div style="position:absolute;top:1.7lh;left:0;height:3lh;width:50%;border:black solid;border-width:0 2px 2px 0"></div><div style="position:absolute;top:1.7lh;left:50%;right:0;border-bottom:2px black solid;"></div></div><div style="display:inline-block;width:15em;min-height:8em;border:1px black solid;padding:0.2em;vertical-align:text-top">
    **Department**<br>
    <u>departmentID *integer NOT NULL*</u><br>
    ...
    </div></div>
4. Place **relationship attributes** in the same table as the foreign key, or in the associative entity if applicable.
6. Normalise your tables:
    a. 1NF - see note below about multivalued attributes
    b. Tables should already satisfy 2NF and 3NF if you created a clean conceptual model
7. Identify attributes that are **spatial** data types, and decide as much as possible on the data type (vector, raster), types of geometries (point, line, polygon, ...) and other properties (dimensionality, Spatial Reference System). Some of this will only become clear once you start sourcing data, possibly after this stage of the process.
8. Consider any constraints that you have not been able to implement in the logical model. Identify where you may need to maintain data integrity using **triggers**. Try to minimise their use. Decide if the trigger is run on `INSERT`, `UPDATE`, or `DELETE` of a record. You do not need to write SQL code at this point of the design process. Simply make a note of what will be required.

::: {.callout-note}
# Multivalued, composite and derived attributes
Multivalued, composite and derived attributes are an awkward fit for the traditional table-based model of a relational database. First normal form (1NF) requires that each "cell" of a table contains a single atomic value. 

If you have studied other database subjects, you might have learned to resolve these attributes like this:

- Resolve a multivalued attribute by splitting it into a separate table, associated to the original table with a one-to-many identifying relationship.
- Resolve a composite attribute by simply adding its component parts to the table as individual columns.
- Remove derived attributes from the model, as they can be handled in your application layer.

However, Postgres offers additional data types which allow us to store multiple pieces of data in a single field, in a way that is understood by the database query engine. 

Despite technically violating 1NF, these storage methods can nonetheless be very useful. Here is a modern perspective on the above recipe:

- Multivalued attributes could be stored using an [Array data type](https://www.postgresql.org/docs/current/arrays.html) (non-spatial), or as Multi* or GeometryCollection geometry columns (spatial).
- Composite attributes could, in some situations, be stored using the powerful [`jsonb` data type](https://www.postgresql.org/docs/current/datatype-json.html).
- Derived attributes can be resolved as generated columns, stored procedures, triggers, or simply removed entirely. You do not need to write SQL code at this point of the design process. Simply make a note of what will be required.
:::

## 1. The simple scenario

::: {.callout-tip title="Your Turn"}
Starting from the conceptual design you completed in last week's practical, prepare a logical design for the employee/department/project database scenario.
:::

For the expression of the model, you can use any drawing technique you wish:

- pen and paper;
- a diagramming tool such as [draw.io](https://www.drawio.com/)
- a dedicated ER modelling tool, such as the ERD Tool in PGAdmin [https://www.pgadmin.org/docs/pgadmin4/development/erd_tool.html](https://www.pgadmin.org/docs/pgadmin4/development/erd_tool.html). This uses a different notation than the one used previously for conceptual modelling – this is part of the logical design step, and ties the design of your tables to the creation of table schemas.

## 2. The project

You are expected to present a logical design as part of Assignment 2. It will help you to think of other aspects of the project (look at all the project specification as well Assignments 4 and 5) as some aspects of the logical design would benefit from knowledge/anticipation of subsequent steps.

For the rest of the session, continue working on your group's conceptual model for Assignment 2. Begin the logical model when you think you have completed your conceptual model.
