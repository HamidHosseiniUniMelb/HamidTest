# [P8] Network analysis


### Objectives 

By the end of this practical you will:

- Understand how pgRouting handles network data for network analysis;
- Be able to create and retrieve information about objects based on their embedding in a network structure; and
- Perform specific network analysis tasks and queries.

## 1. Introduction to networks and pgRouting

A network is a collection of objects *linked* into a structure. The connected (*topological*) structure of the network is typically represented by a set of *nodes*, as well as a set of *edges* (links) which represent connectivity between pairs of nodes. Edges in the network may be directed or undirected. 

A network may capture, for instance, the fabric of streets or railways connecting houses, suburbs and cities. 

To practice network analysis inside our PostgreSQL database, we will be using **pgRouting**. This PostgreSQL extension provides a collection of algorithms for solving network analysis problems, including traversal, routing and accessibility analysis. 

:::{.callout-note}
A set of SQL queries of interest enabling to demonstrate how you build a network topology in PGRouting, a script is here: [Network analysis](../resources/sql/sql06_network_analysis.sql).
:::

### 1.1. pgRouting documentation

The [official documentation for pgRouting](https://docs.pgrouting.org/) lists all available functions and describes how they work. The material is very rough and sometimes difficult to understand, however, it should still give you a general idea of what to do.

Make sure you are reading the documentation for the correct version, as pgRouting is under active development. To check the pgRouting version on Wammawatcha, run the following SQL query:

```sql
SELECT pgr_version();
```

## 2. Simple network analysis

In this section, you will:

- learn how to store a network in a relational DB, and
- learn how to find shortest paths using pgRouting.

### 2.1. Constructing a network

As discussed in this week's lecture, one of the ways to store a network in a database is by forming an **edge list**.

Each edge is written in terms of its two connected nodes. For example, an edge between node 9 and node 12 is written as `9,12`.

The edge list can be implemented as a simple database table called an **edge table**. In this, each edge is given an `id`, and we store the `source` and `target` nodes of that edge:

| `edge_id` | `source` | `target` |
|-----------|----------|----------|
| 15        | 9        | 12       |
| 16        | 4        | 9        |
| ...       | ...      | ...      |

: {.w-auto}

The edge table can contain any other required attributes as additional columns. For instance, in a road network, the edge table could include "name" and "speed limit" attributes.

Optionally, we can also create a **node table** to store the `id` and location (`geom`) of each node, and any other attributes such as node name:

| `node_id` | `geom`        |
|-----------|---------------|
| 1         | `POINT (2 0)` |
| 2         | `POINT (2 1)` |
| ...       | ...           |

: {.w-auto}

::: {.callout-note}
Although we are mixing pgRouting and PostGIS, be aware that these are totally independent, separate extensions. The geometry associated with the nodes *does not have to match at all* with the underlying network topology. For example, the Euclidean distance between nodes is not necessarily the same as the cost associated with the edge connecting those nodes (but it can be the result of the computation of such a distance). 
:::

::: {.callout-tip title="Your Turn"}
1. Create an edge table called `myedge` and a node table called `mynode`. Remember to set the primary key on each table!
2. Fill your `myedge` and `mynode` tables with data corresponding to the network in the picture below. **HINT:** Refer back to [Practical 6](./06_geometrical_queries.qmd#spatial-data-storage) if you need a reminder on how to insert spatial data into a table.
3. Visualise your node table in QGIS.
4. Visualise your edge table in QGIS. **HINT:** Use the QGIS DB Manager to write an SQL query that builds the edge geometries on-the-fly based on the node geometries. You will need to *join* your edge table to your node table - not once but twice. Look up an appropriate PostGIS function for constructing LineStrings from points. 

![](/figs/practicals/p07_network_analysis/network.png)
:::

::: {.callout-caution title="Answers" collapse="true"}
SQL solution for question 1:
```sql
CREATE TABLE myedge (
  edge_id integer NOT NULL,
  source integer NOT NULL,
  target integer NOT NULL,
  PRIMARY KEY (edge_id)
);
CREATE TABLE mynode (
  node_id integer NOT NULL,
  geom geometry(Point) NOT NULL,
  PRIMARY KEY (node_id)
);
-- Note, this network is not in any known SRS, so we do not specify an SRID for the `geom` column
```

SQL solution for question 2:
```sql
INSERT INTO myedge VALUES (1, 1, 2);
INSERT INTO myedge VALUES (2, 2, 3);
INSERT INTO myedge VALUES (3, 3, 4);
-- ... and so on, for all edges

INSERT INTO mynode VALUES (1, 'POINT (2 0)'::geometry);
-- alternatively:
INSERT INTO mynode VALUES (1, ST_Point(2, 0));
-- ... and so on, for all nodes
```

SQL solution for question 4:
```sql
SELECT ST_MakeLine(s.geom, t.geom)
FROM myedge
  INNER JOIN mynode AS s ON s.node_id = source
  INNER JOIN mynode AS t ON t.node_id = target;
```
:::

### 2.2. Shortest path analysis

Dijkstra's algorithm is the classic algorithm for finding the shortest path from one node to another. pgRouting includes the `pgr_dijkstra` function, allowing you to easily run this algorithm on your own network.

pgRouting functions have an unusual syntax. You need to pass an SQL SELECT query as a text parameter. This embedded query must return a defined set of columns with specific names in a certain order.

For example, the official documentation for `pgr_dijkstra` [defines the "one-to-one" function signature](https://docs.pgrouting.org/latest/en/pgr_dijkstra.html#one-to-one) as follows:

```
pgr_dijkstra(Edges SQL, start vid, end vid, [directed])
```

The parameters themselves are defined [under the heading "Parameters"](https://docs.pgrouting.org/latest/en/pgr_dijkstra.html#parameters). The word `vid` stands for `vertex id` - this is what we have named `node_id`. The `directed` parameter is a boolean, `directed:=true` or `directed:=false`, dictating whether the network should be treated as a directed graph, where different forward and reverse costs apply depending on the direction in which the edge is traversededge.

Further down the page, [under the heading "Edges SQL"](https://docs.pgrouting.org/latest/en/pgr_dijkstra.html#edges-sql), the required columns to be returned by the embedded SQL query are listed. They are `id`, `source`, `target`, `cost`, and the optional column `reverse_cost`.

Thus, a basic template for calling `pgr_dijkstra` would be as follows:

```sql
SELECT seq, node, edge, cost, agg_cost
FROM pgr_dijkstra(
  'SELECT ... AS id, ... AS source, ... AS target, ... AS cost [, ... AS reverse_cost]
  FROM edge_table',
  start-node-id, end-node-id,
  directed:=true ...or... directed:=false
);
```

::: {.callout-tip title="Your Turn"}
Use the query template above to find the shortest path from node 7 to node 10 in the network. Set the cost of every edge as 1.
:::

When you run the above query, you should get the following output:

| seq | node | edge | cost | agg_cost |
|:---:|:----:|:----:|:----:|:--------:|
| 1   | 7    | 6    | 1    | 0        |
| 2   | 5    | 9    | 1    | 1        |
| 3   | 9    | 11   | 1    | 2        |
| 4   | 10   | -1   | 0    | 3        |

: {.w-auto}

Look at the table and the network above. Can you work out what the answer to your query means? 

When working with spatial networks, the *cost* of an edge is normally related in some way to the length of that edge. Let's construct the geometry of each edge in the network, and repeat the above problem using the length of each edge as its cost.

::: {.callout-tip title="Your Turn"}
1. Create a *view* of the edge table that includes a dynamically-generated edge geometry column. Use the following SQL code:
```sql
CREATE VIEW myedge_with_geom AS
SELECT myedge.*, ST_MakeLine(s.geom, t.geom) AS geom
FROM myedge
  INNER JOIN mynode AS s ON s.node_id = source
  INNER JOIN mynode AS t ON t.node_id = target;
```

Inspect the contents of this view using `SELECT * FROM myedge_with_geom`. 

2. Find the shortest path from node 7 to node 10, where the cost is the length (`ST_Length`) of each edge. Use the `myedge_with_geom` view. 

3. Rerun the query between several different pairs of nodes, including 7 and 9, 11 and 3, 4 and 12. Each time check the answer carefully to make sure it accords with what you expected. If it doesn't, then investigate and rectify the problem.

4. Now adapt your query to compute only the total cost of each shortest path. Then change it again to list only the path itself, in terms of the sequence of nodes followed.

5. Run the shortest path query between nodes 13 and 10, and from 6 to 16. Is the answer what you expected? Understand what the correct answer should be and why you get that answer.

6. Switch the cost of the edge from nodes 2 to 3 to -1. Now find the shortest route from nodes 1 to 3. What do you notice? What does cost -1 mean? **HINT:** To change the cost, use a [`CASE` statement](https://www.w3schools.com/sql/sql_case.asp) for the `cost` component of the embedded SQL query.

7. Now find the shortest route from 3 to 1, but with reverse edge costs enabled.
:::

### 2.3. A* routing 

Although Dijkstra's algorithm does not require any knowledge of the geometry of the network, the A* algorithm does. (Why? Read the documentation, and think about this.) 

::: {.callout-tip title="Your Turn"}
Run the following A* query using the following query template:

```sql
SELECT seq, node, edge, cost
FROM pgr_astar(
  'SELECT id, source, target, ... AS cost, ... AS x1, ... AS x2, ... AS y1, ... AS y2
   FROM edge_table',
  1, 5
);
```

Note that even though the geometry of the edge end nodes is required for A*, this is not structured as a geometry data type. Work out how to add geometry to the edges using the `geom` column. 
:::

## 3. Advanced routing 

Try the following challenges:

::: {.callout-tip title="Your Turn"}
1. Compute the shortest paths from node 3 to both nodes 1 and 10 in one step using a single pass of the `pgr_dijkstra` function.
2. Compute using an all-pairs shortest path algorithm (e.g., `pgr_floydWarshall`) the costs for paths between every pair of nodes in the network. (And check this carefully. What do you notice?)
3. Use the $k$-shortest paths algorithm to compute the three shortest paths between nodes 11 and 1. **HINT:** Look for an appropriate function in the PostGIS documentation.
4. Now work out how to display the shortest path generated by one of your queries in QGIS. The following query suggestion may assist:
![](../figs/2_part/23_network_analysis/qgis_visualise_path.png)
:::

## 4. Working with real networks

There is a small portion of a real road network, the network around the University of Melbourne, included in the `spatial` schema, tables `spatial.carlton_edges` and `spatial.carlton_nodes`. You can apply the skills you now have to routing in this real road network. 

Have a look at the structure of these tables, and load the data into QGIS to view it. Selecting a suitable origin and destination node, and adapt the routing examples you've already encountered to find the shortest path between those two locations. Note that the routing itself may be a little slower as networks become larger. Use the techniques you developed above to display the shortest path in QGIS.

**Note** on `pgr_createTopology`: You may notice in some documentation there is a function `pgr_createTopology` that is often used on a raw network to find intersections between edges and build the network topology from those intersections. You can experiment with it to create a topology of any network you import. It creates the edge table for you. See the scripts attached to this practical, above.

## Resources

- [Network models and their representations](https://www.researchgate.net/publication/328784715_Street_Network_Studies_from_Networks_to_Models_and_their_Representations)
- [pgRouting Reference Manual](https://docs.pgrouting.org/)
- [pgRouting Workshop](https://workshop.pgrouting.org/2.8/en/index.html) 
- [Understanding Cost Arguments for pgRouting](https://gis.stackexchange.com/questions/48071/how-does-directed-and-has-reverse-cost-arguments-when-set-to-true-false-and)

